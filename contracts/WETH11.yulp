object "WETH11" {
  code {
    // Push this on the stack before datacopy to prevent memory overwrite
    const initialDomainSeparator := calculateDomainSeparator(chainid())

    // Goto runtime.
    datacopy(0, dataoffset("Runtime"), datasize("Runtime"))

    setimmutable("initialChainID", chainid())
    setimmutable("initialDomainSeparator", initialDomainSeparator)

    return(0, datasize("Runtime"))

    function calculateDomainSeparator(chainId) -> domainSeparator {
      // keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")
      mstore(0x0, 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f)
      // name: keccak256("Wrapped Ether 11")
      mstore(0x20, 0xd5ab6b92ca94fac4771fe725a086a0093ce4fe119d380b5dddffede9c0051adb)
      // version: keccak256("1")
      mstore(0x40, 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6)
      mstore(0x60, chainId)
      mstore(0x80, address())

      domainSeparator := keccak256(0x0, 0xa0)
    }
  }

  object "Runtime" {
    code {
      const _calldata := 128 // leave first 4 32 byte chunks for hashing, returns etc..

      enum Storage (balance, allowance, nonce) // storage index numbers.

      if eq(calldatasize(), 0) {
        require(gt(callvalue(), 0), error"empty tx")
        // Fallback payable deposit

        const callerBalanceSlot := mappingStorageKey(caller(), Storage.balance)

        // balanceOf[dst] = add(balanceOf[dst], wad);
        let balanceOfDestination := sload(callerBalanceSlot)
        sstore(callerBalanceSlot, add(balanceOfDestination, callvalue()))

        mstore(0, callvalue())
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            0, caller())
        stop()
      }

      calldatacopy(_calldata, 0, calldatasize()) // copy all calldata to memory.

      switch mslice(_calldata, 4) // 4 byte calldata signature.

      case sig"transfer(address recipient, uint256 amount) public returns (bool success)" {
        mstruct transfer(sig: 4, recipient: 32, amount: 32)

        let recipient := transfer.recipient(_calldata)
        let amount := transfer.amount(_calldata)

        if or(eq(recipient, 0), eq(recipient, address())) {
          withdraw(caller(), caller(), amount)
          mstore(0, true)
          return(0, 32)
        }

        transferFrom(caller(), recipient, amount)
        mstore(0, true)
        return(0, 32)
      }

      case sig"transferAndCall(address recipient, uint256 amount, bytes data) public returns (bool)" {
        mstruct transferAndCall(sig: 4, recipient: 32, amount: 32)

        let recipient := transferAndCall.recipient(_calldata)
        let amount := transferAndCall.amount(_calldata)

        transferFrom(caller(), recipient, transferAndCall.amount(_calldata))

        let dataSize := sub(calldatasize(), 68)

        mstore(0, shl(224, sig"onTokenTransfer(address sender, uint256 value, bytes data) external returns (bool)"))
        mstore(4, caller())
        mstore(36, amount)
        // Note: we can copy the 'data' param directly from the calldata including the offset
        // position, since both calls include the same number of preceeding variables
        calldatacopy(68, 68, dataSize)

        // Call recipient
        let success := call(gas(), recipient, 0, 0, add(dataSize, 68), 0, 0)
        // Ensure recipient is a contract, not an EOA
        require(returndatasize(), error"not a contract")
        // Check that execution succeeded
        require(success, error"hook failed")

        mstore(0, true)
        return(0, 32)
      }

      case sig"transferFrom(address source, address destination, uint amount) public returns (bool success)" {
        mstruct transferFromCalldata(sig: 4, source: 32, destination: 32, amount: 32)

        let source := transferFromCalldata.source(_calldata)
        let destination := transferFromCalldata.destination(_calldata)
        let amount := transferFromCalldata.amount(_calldata)

        if or(eq(destination, 0), eq(destination, address())) {
          withdraw(source, caller(), amount)
          mstore(0, true)
          return(0, 32)
        }

        transferFrom(source, destination, amount)
        mstore(0, true)
        return(0, 32)
      }

      case sig"deposit() public" {
        const depositorBalanceSlot := mappingStorageKey(caller(), Storage.balance)
        // balanceOf[dst] = add(balanceOf[dst], wad);
        let balanceOfDestination := sload(depositorBalanceSlot)
        sstore(depositorBalanceSlot, add(balanceOfDestination, callvalue()))

        mstore(0, callvalue())
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            0, caller())
      }

      case sig"depositTo(address recipient) public" {
        mstruct depositTo(sig: 4, recipient: 32)
        let recipient := depositTo.recipient(_calldata)

        const recipientBalanceSlot := mappingStorageKey(recipient, Storage.balance)
        // balanceOf[dst] = add(balanceOf[dst], wad);
        // TODO: consolidate multiple mappingStorageKey (whole file)
        let balanceOfDestination := sload(recipientBalanceSlot)
        sstore(recipientBalanceSlot, add(balanceOfDestination, callvalue()))

        mstore(0, callvalue())
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            0, recipient)
      }

      case sig"depositToAndCall(address recipient, bytes data) public" {
        mstruct depositToAndCall(sig: 4, recipient: 32)
        let recipient := depositToAndCall.recipient(_calldata)

        const recipientBalanceSlot2 := mappingStorageKey(recipient, Storage.balance)
        // balanceOf[dst] = add(balanceOf[dst], wad);
        // TODO: consolidate multiple mappingStorageKey (whole file)
        let balanceOfDestination := sload(recipientBalanceSlot2)
        sstore(recipientBalanceSlot2, add(balanceOfDestination, callvalue()))

        let dataSize := sub(calldatasize(), 0x44) // Unlike other *AndCall functions, we're not copying the "offset" pos

        mstore(0, shl(224, sig"onTokenTransfer(address sender, uint256 value, bytes data) external returns (bool)"))
        mstore(0x04, caller())
        mstore(0x24, callvalue())
        // Note: we can copy the 'data' param directly from the calldata including the offset
        // position, since both calls include the same number of preceeding variables
        mstore(0x44, 0x60) // The 'data' param is stored at offset 0x60 in the calldata (not including signature)
        calldatacopy(0x64, 0x44, dataSize)

        // Call recipient
        let success := call(gas(), recipient, 0, 0, add(dataSize, 0x64), 0, 0)
        // Ensure recipient is a contract, not an EOA
        require(returndatasize(), error"not a contract")
        // Check that execution succeeded
        require(success, error"hook failed")

        mstore(0, callvalue())
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            0, recipient)
      }

      case sig"withdraw(uint amount) public" {
        mstruct withdraw(sig: 4, amount: 32)
        let amount := withdraw.amount(_calldata)

        withdraw(caller(), caller(), amount)
      }

      case sig"withdrawTo(address recipient, uint amount) public" {
        mstruct withdrawTo(sig: 4, recipient: 32, amount: 32)
        let amount := withdrawTo.amount(_calldata)

        withdraw(caller(), withdrawTo.recipient(_calldata), amount)
      }

      case sig"withdrawFrom(address source, address recipient, uint amount) public" {
        mstruct withdrawFrom(sig: 4, source: 32, recipient: 32, amount: 32)
        let amount := withdrawFrom.amount(_calldata)
        let source := withdrawFrom.source(_calldata)

        withdraw(source, withdrawFrom.recipient(_calldata), amount)
      }

      case sig"approve(address destination, uint256 amount) public returns (bool success)" {
        mstruct approve(sig: 4, destination: 32, amount: 32)

        sstore(mappingStorageKey2(caller(),
            approve.destination(_calldata),
            Storage.allowance), approve.amount(_calldata))

        mstore(0, approve.amount(_calldata))
        log3(0, 32,
            topic"event Approval(address indexed source, address indexed destination, uint256 amount)",
            caller(),
            approve.destination(_calldata))

        mstore(0, true)
        return(0, 32)
      }

      case sig"approveAndCall(address recipient, uint256 amount, bytes data) public returns (bool)" {
        mstruct approveAndCall(sig: 4, recipient: 32, amount: 32)

        let recipient := approveAndCall.recipient(_calldata)
        let amount := approveAndCall.amount(_calldata)

        sstore(mappingStorageKey2(caller(), recipient, Storage.allowance), amount)

        mstore(0, amount)
        log3(0, 32,
            topic"event Approval(address indexed source, address indexed destination, uint256 amount)",
            caller(),
            recipient)

        let dataSize := sub(calldatasize(), 68)

        mstore(0, shl(224, sig"onTokenApproval(address sender, uint256 value, bytes data) external returns (bool)"))
        mstore(4, caller())
        mstore(36, amount)
        // Note: we can copy the 'data' param directly from the calldata including the offset
        // position, since both calls include the same number of preceeding variables
        calldatacopy(68, 68, dataSize)

        // Call recipient
        let success := call(gas(), recipient, 0, 0, add(dataSize, 68), 0, 0)
        // Ensure recipient is a contract, not an EOA
        require(returndatasize(), error"not a contract")
        // Check that execution succeeded
        require(success, error"hook failed")

        mstore(0, true)
        return(0, 32)
      }

      case sig"permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external" {
        mstruct permit(sig: 4, owner: 32, spender: 32, value: 32, deadline: 32, v: 32, r: 32, s: 32)

        // Load the calldata onto the stack. We're going to overwrite the first few values soon
        const owner := permit.owner(_calldata)
        const spender := permit.spender(_calldata)
        const value := permit.value(_calldata)
        const deadline := permit.deadline(_calldata)
        const v := permit.v(_calldata)
        const r := permit.r(_calldata)
        const s := permit.s(_calldata)

        require(gt(permit.deadline(_calldata), timestamp()), error"PermitExpired()")

        const nonceSlot := mappingStorageKey(Storage.nonce, owner)
        let nonce := sload(nonceSlot)
        // nonce[owner] += 1
        sstore(nonceSlot, add(nonce, 1))

        // keccak("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")
        mstore(0x0, 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9)
        mstore(0x20, owner)
        mstore(0x40, spender)
        mstore(0x60, value)
        mstore(0x80, nonce)
        mstore(0xa0, deadline)
        const hashStruct := keccak256(0x0, 0xc0)

        let domainSeparator := loadimmutable("initialDomainSeparator")
        if neq(loadimmutable("initialChainID"), chainid()) {
          // If the chainId has changed (chain fork), recalculate the separator
          domainSeparator := calculateDomainSeparator(chainid())
        }

        mstore(0x0, 0x1901000000000000000000000000000000000000000000000000000000000000)
        mstore(0x2, domainSeparator)
        mstore(0x22, hashStruct)
        const hash := keccak256(0x0, 0x42)

        mstore(0, hash)
        mstore(0x20, v)
        mstore(0x40, r)
        mstore(0x60, s)
        const ecrecoverSuccess := staticcall(gas(), 0x1, 0, 128, 0, 32) // ecrecover(hash, v, r, s)
        require(ecrecoverSuccess)
        const signer := mload(0)

        const signerIsNotZero := neq(signer, 0x00)
        require(signerIsNotZero, error"Signer is zero")

        const signerIsOwner := eq(signer, owner)
        require(signerIsOwner, error"Invalid signature")

        sstore(mappingStorageKey2(owner, spender, Storage.allowance), value)

        mstore(0, value)
        log3(0, 32,
            topic"event Approval(address indexed source, address indexed destination, uint256 amount)",
            owner,
            spender)
      }

      case sig"allowance(address source, address spender) public view returns (uint256 allowance)" {
        mstruct allowanceCalldata(sig: 4, source: 32, spender: 32)

        mstore(0, sload(mappingStorageKey2(allowanceCalldata.source(_calldata),
            allowanceCalldata.spender(_calldata),
            Storage.allowance)))
        return (0, 32)
      }

      case sig"name() public view returns (string)" {
        mstore(0, 0x20)

        let length := 16
        mstore(0x20, length)
        mstore(0x40, "Wrapped Ether 11")

        return(0, 0x60)
      }

      case sig"symbol() public view returns (string)" {
        mstore(0, 0x20)

        let length := 6
        mstore(0x20, length)
        mstore(0x40, "WETH11")

        return(0, 0x60)
      }

      case sig"decimals() public view returns (uint8)" {
        mstore(0, 18)
        return(0, 32)
      }

      case sig"totalSupply() public view returns (uint256)" {
        mstore(0, selfbalance())
        return(0, 32)
      }

      case sig"DOMAIN_SEPARATOR() public view returns (bytes32)" {
        if eq(loadimmutable("initialChainID"), chainid()) {
          mstore(0, loadimmutable("initialDomainSeparator"))
          return(0, 32)
        }

        // If the chainId is different than when the contract was deployed,
        // then we need to re-calculate the domain seperator each time
        mstore(0, calculateDomainSeparator(chainid()))
        return(0, 32)
      }

      case sig"balanceOf(address owner) public view returns (uint256 balance)" {
        mstruct calldata.balanceOf(sig: 4, owner: 32)
        mstore(0, sload(mappingStorageKey(calldata.balanceOf.owner(_calldata),
            Storage.balance)))
        return (0, 32)
      }

      case sig"nonces(address owner) public view returns (uint256 balance)" {
        mstruct calldata.nonce(sig: 4, owner: 32)
        mstore(0, sload(mappingStorageKey(calldata.nonce.owner(_calldata),
            Storage.nonce)))
        return (0, 32)
      }

      default { require(0) } // invalid method signature.

      stop() // stop execution here..

      function transferFrom(source, destination, amount) {
        const sourceBalanceSlot := mappingStorageKey(source, Storage.balance)
        const desinationBalanceSlot := mappingStorageKey(destination, Storage.balance)
        const balanceOfSource := sload(sourceBalanceSlot)

        // require(balanceOf[src] >= wad, "Dai/insufficient-balance");
        require(gte(balanceOfSource, amount), error"insufficient-balance")

        // if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
        if neq(source, caller()) {
          const sourceAllowanceSlot := mappingStorageKey2(source, caller(), Storage.allowance)
          const allowanceOfSourceSender := sload(sourceAllowanceSlot)

          // if (allowance[src][msg.sender] != uint(-1))
          // Skip the allowance SSTORE if the allowance is MAX_INT
          if neq(allowanceOfSourceSender, MAX_UINT) {
            // require(allowance[src][msg.sender] >= wad, "Dai/insufficient-allowance");
            require(gte(allowanceOfSourceSender, amount), error"insufficient-allowance")

            // allowance[src][msg.caller] = sub(allowance[src][msg.caller], wad);
            sstore(sourceAllowanceSlot, sub(allowanceOfSourceSender, amount))
          }
        }

        //  balanceOf[src] = sub(balanceOf[src], wad);
        sstore(sourceBalanceSlot, sub(balanceOfSource, amount))

        // balanceOf[dst] = add(balanceOf[dst], wad);
        const balanceOfDestination := sload(desinationBalanceSlot)
        sstore(desinationBalanceSlot, add(balanceOfDestination, amount))

        mstore(0, amount)
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            source, destination)
      }

      function withdraw(source, destination, amount) {
        const balanceSlot := mappingStorageKey(source, Storage.balance)

        let balanceOfCaller := sload(balanceSlot)
        require(gte(balanceOfCaller, amount), error"insufficient-balance")

        if neq(source, caller()) {
          // require(allowance[source][msg.sender] >= wad, "insufficient-allowance");
          let allowanceStorageKey := mappingStorageKey2(source, caller(), Storage.allowance)
          let allowanceOfSourceSender := sload(allowanceStorageKey)
          require(gte(allowanceOfSourceSender, amount), error"insufficient-allowance")

          if neq(allowanceOfSourceSender, MAX_UINT) {
            // allowance[source][msg.sender] = sub(allowance[source][msg.sender], wad);
            sstore(allowanceStorageKey, sub(allowanceOfSourceSender, amount))
          }
        }

        // balanceOf[dst] = sub(balanceOf[dst], wad);
        sstore(balanceSlot, sub(balanceOfCaller, amount))

        // ETH transfer
        let success := call(gas(), destination, amount, 0, 0, 0, 0)
        require(success, error"withdraw failed")

        mstore(0, amount)
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            source, 0)
      }

      // Duplicate code used in the constructor
      function calculateDomainSeparator(chainId) -> domainSeparator {
        // keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")
        mstore(0x0, 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f)
        // name: keccak256("Wrapped Ether 11")
        mstore(0x20, 0xd5ab6b92ca94fac4771fe725a086a0093ce4fe119d380b5dddffede9c0051adb)
        // version: keccak256("1")
        mstore(0x40, 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6)
        mstore(0x60, chainId)
        mstore(0x80, address())

        domainSeparator := keccak256(0x0, 0xa0)
      }

      // Solidity Style Storage Key: mapping(bytes32 => bytes32)
      function mappingStorageKey(key, storageIndex) -> storageKey {
        mstore(0, key, storageIndex)
        storageKey := keccak256(0, 64)
      }

      // Solidity Style Storage Key: mapping(bytes32 => mapping(bytes32 => bytes32)
      function mappingStorageKey2(key, key2, storageIndex) -> storageKey {
        mstore(0, key, storageIndex, key2)
        mstore(96, keccak256(0, 64))
        storageKey := keccak256(64, 64)
      }
    }
  }
}
