object "WETH11" {
  code {
    // Goto runtime.
    datacopy(0, dataoffset("Runtime"), datasize("Runtime"))
    return(0, datasize("Runtime"))
  }
  object "Runtime" {
    code {
      const _calldata := 128 // leave first 4 32 byte chunks for hashing, returns etc..

      enum Storage (balance, allowance) // storage index numbers.

      if eq(calldatasize(), 0) {
        require(gt(callvalue(), 0), error"empty tx")
        // Fallback payable deposit

        // balanceOf[dst] = add(balanceOf[dst], wad);
        let balanceOfDestination := sload(mappingStorageKey(caller(), Storage.balance))
        sstore(mappingStorageKey(caller(), Storage.balance),
            add(balanceOfDestination, callvalue()))

        // totalSupply
        sstore(0, add(sload(0), callvalue()))

        mstore(0, callvalue())
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            0, caller())
        stop()
      }

      calldatacopy(_calldata, 0, calldatasize()) // copy all calldata to memory.

      switch mslice(_calldata, 4) // 4 byte calldata signature.

      case sig"transfer(address owner, uint256 amount) public returns (bool success)" {
        mstruct transfer(sig: 4, owner: 32, amount: 32)

        transferFrom(caller(),
          transfer.owner(_calldata),
          transfer.amount(_calldata))
      }

      case sig"transferFrom(address source, address destination, uint amount) public returns (bool success)" {
          mstruct transferFromCalldata(sig: 4, source: 32, destination: 32, amount: 32)

          transferFrom(transferFromCalldata.source(_calldata),
              transferFromCalldata.destination(_calldata),
              transferFromCalldata.amount(_calldata))
      }

      case sig"deposit() public" {
        // balanceOf[dst] = add(balanceOf[dst], wad);
        let balanceOfDestination := sload(mappingStorageKey(caller(), Storage.balance))
        sstore(mappingStorageKey(caller(), Storage.balance),
            add(balanceOfDestination, callvalue()))

        // totalSupply
        sstore(0, add(sload(0), callvalue()))

        mstore(0, callvalue())
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            0, caller())
      }

      case sig"depositTo(address recipient) public" {
        mstruct depositTo(sig: 4, recipient: 32)
        let recipient := depositTo.recipient(_calldata)

        // balanceOf[dst] = add(balanceOf[dst], wad);
        // TODO: consolidate multiple mappingStorageKey (whole file)
        let balanceOfDestination := sload(mappingStorageKey(recipient, Storage.balance))
        sstore(mappingStorageKey(recipient, Storage.balance),
            add(balanceOfDestination, callvalue()))

        // totalSupply
        sstore(0, add(sload(0), callvalue()))

        mstore(0, callvalue())
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            0, recipient)
      }

      case sig"withdraw(uint amount) public" {
        mstruct withdraw(sig: 4, amount: 32)
        let amount := withdraw.amount(_calldata)

        // balanceOf[dst] = add(balanceOf[dst], wad);
        let balanceOfDestination := sload(mappingStorageKey(caller(), Storage.balance))
        // TODO: check for balance
        sstore(mappingStorageKey(caller(), Storage.balance),
            sub(balanceOfDestination, amount))

        // totalSupply
        sstore(0, sub(sload(0), amount))

        // ETH transfer
        let success := call(gas(), caller(), amount, 0, 0, 0, 0)
        require(success, error"withdraw failed")

        mstore(0, amount)
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            caller(), 0)
      }

      case sig"withdrawTo(address recipient, uint amount) public" {
        mstruct withdrawTo(sig: 4, recipient: 32, amount: 32)
        let amount := withdrawTo.amount(_calldata)

        let balanceOfSender := sload(mappingStorageKey(caller(), Storage.balance))

        // require(balanceOf[src] >= wad, "Dai/insufficient-balance");
        require(or(gt(balanceOfSender, amount), eq(balanceOfSender, amount)), error"insufficient-balance")

        sstore(mappingStorageKey(caller(), Storage.balance),
            sub(balanceOfSender, amount))

        // totalSupply
        sstore(0, sub(sload(0), amount))

        // ETH transfer
        let success := call(gas(), withdrawTo.recipient(_calldata), amount, 0, 0, 0, 0)
        require(success, error"withdraw failed")

        mstore(0, amount)
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            caller(), 0)
      }

      case sig"withdrawFrom(address source, address recipient, uint amount) public" {
        mstruct withdrawFrom(sig: 4, source: 32, recipient: 32, amount: 32)
        let amount := withdrawFrom.amount(_calldata)
        let source := withdrawFrom.source(_calldata)

        let balanceOfSource := sload(mappingStorageKey(source, Storage.balance))
        let allowanceOfSourceSender := sload(mappingStorageKey2(source, caller(), Storage.allowance))

        // require(balanceOf[src] >= wad, "Dai/insufficient-balance");
        require(gte(balanceOfSource, amount), error"insufficient-balance")

        // if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
        if and(neq(source, caller()), neq(allowanceOfSourceSender, MAX_UINT)) {
          // require(allowance[src][msg.sender] >= wad, "Dai/insufficient-allowance");
          require(gte(allowanceOfSourceSender, amount), error"insufficient-allowance")

          // allowance[src][msg.caller] = sub(allowance[src][msg.caller], wad);
          sstore(mappingStorageKey2(source, caller(), Storage.allowance),
              sub(allowanceOfSourceSender, amount))
        }

        //  balanceOf[src] = sub(balanceOf[src], wad);
        sstore(mappingStorageKey(source, Storage.balance),
            sub(balanceOfSource, amount))

        // totalSupply
        sstore(0, sub(sload(0), amount))

        // ETH transfer
        let success := call(gas(), withdrawFrom.recipient(_calldata), amount, 0, 0, 0, 0)
        require(success, error"withdraw failed")

        mstore(0, amount)
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            caller(), 0)
      }

      case sig"approve(address destination, uint256 amount) public returns (bool success)" {
        mstruct approve(sig: 4, destination: 32, amount: 32)

        sstore(mappingStorageKey2(caller(),
            approve.destination(_calldata),
            Storage.allowance), approve.amount(_calldata))

        mstore(0, approve.amount(_calldata))
        log3(0, 32,
            topic"event Approval(address indexed source, address indexed destination, uint256 amount)",
            caller(),
            approve.destination(_calldata))

        mstore(0, true)
        return(0, 32)
      }

      case sig"allowance(address source, address spender) public view returns (uint256 allowance)" {
        mstruct allowanceCalldata(sig: 4, source: 32, spender: 32)

        mstore(0, sload(mappingStorageKey2(allowanceCalldata.source(_calldata),
            allowanceCalldata.spender(_calldata),
            Storage.allowance)))
        return (0, 32)
      }

      case sig"name() public view returns (string)" {
        mstore(0, 0x20)

        let length := 16
        mstore(0x20, length)
        mstore(0x40, "Wrapped Ether 11")

        return(0, 0x60)
      }

      case sig"symbol() public view returns (string)" {
        mstore(0, 0x20)

        let length := 6
        mstore(0x20, length)
        mstore(0x40, "WETH11")

        return(0, 0x60)
      }

      case sig"decimals() public view returns (uint8)" {
        mstore(0, 18)
        return(0, 32)
      }

      case sig"totalSupply() public view returns (uint256)" {
        mstore(0, sload(0))
        return(0, 32)
      }

      case sig"balanceOf(address owner) public view returns (uint256 balance)" {
        mstruct calldata.balanceOf(sig: 4, owner: 32)
        mstore(0, sload(mappingStorageKey(calldata.balanceOf.owner(_calldata),
            Storage.balance)))
        return (0, 32)
      }

      default { require(0) } // invalid method signature.

      stop() // stop execution here..

      function transferFrom(source, destination, amount) {
        let balanceOfSource := sload(mappingStorageKey(source, Storage.balance))
        let allowanceOfSourceSender := sload(mappingStorageKey2(source, caller(), Storage.allowance))

        // require(balanceOf[src] >= wad, "Dai/insufficient-balance");
        require(or(gt(balanceOfSource, amount), eq(balanceOfSource, amount)), error"insufficient-balance")

        // if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
        if and(neq(source, caller()), neq(allowanceOfSourceSender, MAX_UINT)) {
          // require(allowance[src][msg.sender] >= wad, "Dai/insufficient-allowance");
          require(gte(allowanceOfSourceSender, amount), error"insufficient-allowance")

          // allowance[src][msg.caller] = sub(allowance[src][msg.caller], wad);
          sstore(mappingStorageKey2(source, caller(), Storage.allowance),
              sub(allowanceOfSourceSender, amount))
        }

        //  balanceOf[src] = sub(balanceOf[src], wad);
        sstore(mappingStorageKey(source, Storage.balance),
            sub(balanceOfSource, amount))

        // balanceOf[dst] = add(balanceOf[dst], wad);
        let balanceOfDestination := sload(mappingStorageKey(destination, Storage.balance))
        sstore(mappingStorageKey(destination, Storage.balance),
            add(balanceOfDestination, amount))

        mstore(0, amount)
        log3(0, 32, topic"event Transfer(address indexed source, address indexed destination, uint amount)",
            source, destination)

        mstore(0, true)
        return(0, 32)
      }

      // Solidity Style Storage Key: mapping(bytes32 => bytes32)
      function mappingStorageKey(key, storageIndex) -> storageKey {
        mstore(0, key, storageIndex)
        storageKey := keccak256(0, 64)
      }

      // Solidity Style Storage Key: mapping(bytes32 => mapping(bytes32 => bytes32)
      function mappingStorageKey2(key, key2, storageIndex) -> storageKey {
        mstore(0, key, storageIndex, key2)
        mstore(96, keccak256(0, 64))
        storageKey := keccak256(64, 64)
      }
    }
  }
}
